export
    automate


function default_monodromy_describe()
     true
end

function automate(E::EnumerativeProblem; describe_monodromy = default_monodromy_describe(), kwargs...)
    n = ambient_dimension(E)
    k = n_parameters(E)
    m = n_polynomials(E)

    bezout_bound = bezout(E)
    bkk_bound = bkk(E)
    bkk_bound_torus = bkk(E;only_torus=true)
    d = degree(E)
    G = galois_group(E)
    N = 1000
    (P,fun_names,data) = explore(E,[real_points_in_fibre,positive_points_in_fibre]; n_samples = N)




    println("----------------------------------------------")
    println("-----------------ANALYSIS---------------------")
    println("----------------------------------------------")


    println("----------------------------------------------")
    println("--------------------basic---------------------")
    println("----------------------------------------------")
    println("This is an enumerative problem in ",n," variables, cut out by ",m," polynomials over ",k," parameters.")
    println("The degree counts d<=bkk in affine space<=bezout are given by ")
    println("                          V|  ")
    println("                     bkk in torus  ")
    println("    ",d,"<=",bkk_bound,"<=",bezout_bound)
    println("                V|")
    println("             ",bkk_bound_torus)

    println("----------------------------------------------")
    println("---------------monodromy/galois---------------")
    println("----------------------------------------------")
    println("The Galois group/monodromy group is ")
    if get(kwargs,:describe_monodromy,false) && println(describe(G))
    else
        print("computed, but not described,")
    end
    println("   and has order ",order(G))
    println("   In particular it is ")
    if is_transitive(G)
        println("        transitive")
        if is_primitive(G)
            println("        primitive")
        else
            println("        not primitive, with blocks of imprimitivity generated by ")
            for m in minimal_block_reps(G)
                println("             ",m)
            end
        end
    else
        println("        not transitive, with orbits of size")
        for o in orbits(G)
            println("            ",length(o))
        end
    end


        

    println("----------------------------------------------")
    println("---------------reality/positivity-------------")
    println("----------------------------------------------")
    println("We solved the problem for ",N, " random fibres and found")
    println("   Number of real solutions:")
    T1 = tally(data[1])
    for k in sort(collect(keys(T1)))
        println("       ",k,"->",T1[k])
    end
    println("   Number of positive solutions:")
    T2 = tally(data[2])
    for k in sort(collect(keys(T2)))
        println("       ",k,"->",T2[k])
    end
    Obucket = []
    N_trials=20
    N_samples=10
    shotgun_count=3
    for i in 1:shotgun_count
        O = optimize_real(E;n_trials = N_trials, n_samples=N_samples)
     push!(Obucket,O)
    end

    records = [O.record_score[1] for O in Obucket]
    max_record = max(records...)

    println("----------------------------------------------")
    println("------------optimizing reality----------------")
    println("----------------------------------------------")
    println("After running an optimization scheme with ",N_trials," trials ", shotgun_count, " times")
    println("  we found this many solutions:")
    println("  ",sort(records))
    println("The maximum of ", max_record, " was achieved by the parameters")
    println("  ",Obucket[argmax(records)].record_fibre[2])

    (v,P) = visualize_parameter_space(E;near = Obucket[argmax(records)].record_fibre[2])
    show(P)
    return(P)
end